#! /usr/bin/perl

use strict;
use FindBin;
use lib "$FindBin::Bin/lib";

use Pegex;
use File::Slurp;
use Getopt::Long;

my $grammar = <<'...';
# Precedence Climbing grammar:
program: declarations main begin statements end

# General Tokens
line: / ANY* EOL /
comment: / '//' line /
ws: /(: BLANK | EOL | comment )/

# declarations
declarations: vardecls*
vardecls: pragma | vardecl | datastmt | subdecl
pragma: /- HASH 'pragma' - name - ( NS+ ) -/
vardecl: /- 'var' -/ declinit+ %% COMMA /- SEMI -/
declinit: assign | declare
declare: variable dimension?
dimension: /- LSQUARE -/ cardinal /- RSQUARE -/
subdecl: /- 'sub' -/ subsign block
subsign: name /- LPAREN -/ formparam* %% COMMA /- RPAREN -/
formparam: (valparam | refparam)
valparam: (/- 'val' -/) variable
refparam: (/- 'ref' -/)? variable
main: /- 'main'/

# statements
statements:  statement*
statement: assignstmt | readstmt | datareset | control | subcall
subcall: /- 'call' -/ variable params /- SEMI/
params: /- LPAREN -/ expr* %% COMMA /- RPAREN -/
control: if | loop | stopon
assignstmt: assign /- SEMI -/
assign: variable /- '<-' -/ expr

# loop
loop: loopcmd block
loopcmd: /- 'loop' -/ 
stopon: /- 'stop' + 'on' - LPAREN -/ gocondition /- RPAREN - SEMI/

# if-else
if: ifblock elseblock?
ifblock: /- 'if' - LPAREN -/ docondition /- RPAREN -/ block
elseblock: elsecmd block
elsecmd: /- 'else' -/ 

# data statements
datastmt: /- 'data' -/ number+ %% COMMA /- SEMI -/
readstmt: /- 'read' -/ variable+ %% COMMA /- SEMI -/
datareset: /- 'reset' - SEMI -/

# misc stuff
docondition: condition
gocondition: condition 
condition: expr /- ([ '<=>' ]+) -/ expr
block: begin statements end
begin: /- LCURLY -/
end: /- RCURLY -/

# expressions
expr: /- ( '-'? ) / addsub
addsub: muldiv+ % /- ( [ '+-' ])/
muldiv: token+ % /- ([ '*/' ])/
token: /- LPAREN -/ expr /- RPAREN/ | number | variable
variable: /- ( ALPHA WORD* ) / index?
name: /- ( ALPHA WORD* ) /
index: /- LSQUARE -/ expr /- RSQUARE -/
number: /- ( '-'? DIGIT+ )/
cardinal: /- ( DIGIT+ )/
...

{
    package Shla;
    use Data::Dumper;
    use base 'Pegex::Tree';

    my $maxnum;

    my %opcode = (
	'+' => 'ADD',
	'-' => 'SUB',
	'*' => 'MUL',
	'/' => 'DIV',
	'<-' => 'MOV',
	);

    my $t = 10; # start of tmp cells
    my $labelno = 0;
    my @ilabels = ();
    my @llabels = ();
    my @slabels = ();
    my %locsym = ();
    my $haslbl = 0;
    my $isdecl = 0;
    my $cursub = undef;

    sub scope {
	my $var = shift;
	my $para = shift;
	# print "LOCSYM $cursub:$var: " . Dumper(%locsym);
	if($var =~ /^\d+/) {
	    return "#$var";
	}
	my $locnam = "$cursub:$var";
	if(exists $locsym{$locnam}) {
	    my ($frmpos, $cby) = @{$locsym{$locnam}};
	    print "\t" if !$haslbl;
	    print "SUB FRMPTR #$frmpos $t\n";
	    print "\tMOV *$t $t\n" if($cby eq 'ref');
	    $haslbl = 0;
	    if($para =~ /array/) {
		$var = "\@$t"
	    } else {
		$var = "*$t"
	    }
	}
	if($para =~ /persist/) {
	    $t++;
	}
	return $var;
    }

    sub initial {
	$maxnum =  (1 << $main::bits) - 1;
	# print "MAXNUM: $maxnum bits $main::bits\n";
	print "; shlc SHLA compilation " . localtime() . "\n";
	print "; this assumes a TAC with $main::bits bit word width\n";
	print "; mem locs 1-255 are local local or temporary vars\n";
	print "RESET:\tJMP MAIN\n";
	print "STKPTR:\tMEM 255\n";
	print "FRMPTR:\tMEM 255\n";
	print ".=\t256\n";
	$isdecl = 1;

        my ($self, $list) = @_;
        return $list unless ref $list;

        return @$list;
    }

    sub got_main {
	$isdecl = 0;
	print "MAIN:\t";
	$haslbl = 1;
    
        my ($self, $list) = @_;
        return $list unless ref $list;

        return @$list;
    }

    sub got_declare {
        my ($self, $list) = @_;
	# print "VARDECL: " . Dumper($list);
        return $list unless ref $list;
	my ($var, $dim) = splice(@$list, 0, 2);

	# print "DECL: $var - $dim\n";
	my $val = 0;
	$val = "0*$dim" if $dim;
	if($isdecl) {
	    print "$var=\tMEM $val\n";
	}
        return; # @$list;
    }

    sub got_assign {
        my ($self, $list) = @_;
        return $list unless ref $list;

	while (@$list > 1) {
	    my ($var, $val) = splice(@$list, 0, 2);
	    if($isdecl) {
		print "$var=\tMEM $val\n";
	    } else {
		$var = scope($var, 'lvalue');
		$val = scope($val);
		print "\t" if !$haslbl;
		print "MOV $val $var\n";
		$haslbl = 0;
	    }
	}
        return @$list;
    }

    sub got_docondition {
        my ($self, $list) = @_;
        return $list unless ref $list;

	# print "DO-COND" . join('/', @$list) . "\n";
	my ($a, $rel, $b) = splice(@$list, 0, 3);

	$haslbl = makecond($a, $rel, $b, $haslbl, 'do');

        return @$list;
    }

    sub got_gocondition {
        my ($self, $list) = @_;
        return $list unless ref $list;

	# print "GO-COND" . join('/', @$list) . "\n";
	my ($a, $rel, $b) = splice(@$list, 0, 3);

	$haslbl = makecond($a, $rel, $b, $haslbl, 'go');

        return @$list;
    }

    sub got_condition {
        my ($self, $list) = @_;
        return $list unless ref $list;
	#print "rule: " . join('/', @$list) . "\n";

        return $list;
    }


    sub makecond {
	my ($a, $rel, $b, $haslbl, $mode) = @_;

	push @ilabels, ++$labelno;
	my $endlop = sprintf "L%05d", $labelno;
	my $doorgo = ($mode eq 'do');

	my @jumps = ();
	if($rel eq '=') {
	    push @jumps, ($doorgo ? 'JNE' : 'JEQ');
	} elsif($rel eq '<>') {
	    push @jumps, ($doorgo ? 'JEQ' : 'JNE');
	} elsif($rel eq '>') {
	    push @jumps, ($doorgo ? ('JEQ', 'JLE') : 'JGT');
	} elsif($rel eq '=>') {
	    push @jumps, ($doorgo ? 'JLE' : ('JEQ', 'JGT'));
	} elsif($rel eq '<') {
	    push @jumps, ($doorgo ? ('JEQ', 'JGT') : 'JLE');
	} elsif($rel eq '<=') {
	    push @jumps, ($doorgo ? 'JGT' : ('JEQ', 'JLE'));
	} else {
	    die "FATAL: Undefined relational operator '$rel'.\n";
	}
	print "\t" if !$haslbl;
	## SCOPE?
	$a = "#$a" if($a =~ /^\d/);
	$b = "#$b" if($b =~ /^\d/);
	print "CMP $a $b\n";
	foreach my $jump (@jumps) {
	    print "\t$jump $endlop\n";
	}
	$haslbl = 0;

	return $haslbl;
    }

    sub got_loopcmd {
	if($haslbl) {
	    print "NOP\n";
	    $haslbl = 0;
	}
	my $startlbl = ++$labelno;
	push @llabels, $startlbl;
	printf "L%05d:\t", $startlbl;
	$haslbl = 1;
	
        my ($self, $list) = @_;
        return $list unless ref $list;

        return @$list;
    }

    sub got_elsecmd {
	#my $lno0 = pop @ilabels; # unused if label
	my $elselbl = pop @ilabels; # target of not-cond
	push @ilabels, ++$labelno;
	printf "\tJMP L%05d\n", $labelno;
	printf "L%05d:\t", $elselbl;
	$haslbl = 1;
	
        my ($self, $list) = @_;
        return $list unless ref $list;

        return @$list;
    }

    sub got_stopon {
	my $brkno = pop @ilabels;
	push @llabels, $brkno;
	
        my ($self, $list) = @_;
        return $list unless ref $list;

        return @$list;
    }

    sub got_valparam {
        my ($self, $list) = @_;
	return $list unless ref $list;
	# print "VALPP: " . join('/', @$list) . "\n";
	my ($name) = splice(@$list, 0, 1);

	unshift @$list, "val:$name";

        return @$list;
    }

    sub got_refparam {
        my ($self, $list) = @_;
	return $list unless ref $list;
	# print "REFP: " . join('/', @$list) . "\n";
	my ($name) = splice(@$list, 0, 1);

	unshift @$list, "ref:$name";
	
        return @$list;
    }

    sub got_subsign {
	$isdecl = 0;
        my ($self, $list) = @_;
	return $list unless ref $list;
	# print "SUBSIGN: " . join('/', @$list) . "\n";

	my $frmpos = 0;
	while (@$list > 1) {
	    my ($name, $params) = splice(@$list, 0, 2);
	    # print "SUBPARA $name: " . Dumper(@$params);
	    foreach my $obj (@$params) {
		if(defined $obj) {
		    my ($cby, $var) = split /:/, $obj;
		    my $locnam = "$name:$var";
		    # print "LOCAL $cby $locnam\n";
		    $locsym{$locnam} = [$frmpos++, $cby];
		}
	    }

	    printf "%-6s\tMEM 0\n", "$name:";
	    push @slabels, $name;
	    $frmpos = "#$frmpos" unless($frmpos =~/^\@/);
	    unshift @$list, "$frmpos";
	    $cursub = $name;
	}

	return @$list;
    }

    sub got_subdecl {
	$isdecl = 1;
        my ($self, $list) = @_;
        return $list unless ref $list;
	# print "SUBDECL: " . join('/', @$list) . "\n";
	while (@$list > 0) {
	    my ($frmoff) = splice(@$list, 0, 1);
	    # printf "\tADD STKPTR $frmoff STKPTR\n"
	    print "\tMOV FRMPTR STKPTR\n"
		if($frmoff && $frmoff ne '#0');
	}

	my $sub = pop @slabels;
	printf "\tJMP *%s\n", $sub;
	$cursub = undef;
	
	return @$list;
    }

    sub got_subcall {
        my ($self, $list) = @_;
        return $list unless ref $list;
	# print "CALL: " . join('/', @$list) . "\n";

 	while (@$list > 0) {
	    my ($name, $params) = splice(@$list, 0, 2);
	    # print "CALL PARAMS: " . Dumper($params);
	    my $myfrm = $t++;
	    print "\t" if !$haslbl;	   
	    print "MOV FRMPTR $myfrm\n"; 
	    print "\tMOV STKPTR FRMPTR\n"; 
	    foreach my $obj (@$params) {
		if(defined $obj) {
		    # print "CHECKLOC: $cursub:$obj\n";
		    my $locnam = "$cursub:$obj";
		    if(exists $locsym{$locnam}) {
			my ($frmpos, $cby) = @{$locsym{$locnam}};
			print "\tSUB $myfrm #$frmpos $t\n";
			print "\tMOV *$t $t\n" if($cby eq 'ref');
			$obj = "$t";
		    } else {
			$obj = "#$obj" unless($obj =~ /^\@/);
		    }
		    print "\tMOV $obj *STKPTR\n";
		    print "\tSUB STKPTR #1 STKPTR\n";
		}
	    }
	    printf "\tJSR %s\n", $name;
	    $haslbl = 0;
	}
        return @$list;
    }

    sub got_block {
        my ($self, $list) = @_;
        return $list unless ref $list;

        return @$list;
    }

    sub got_loop {
	my $brklbl = pop @llabels;
	my $loplbl = pop @llabels;

	print "\t" if !$haslbl;
	printf "JMP L%05d\n", $loplbl;
	$haslbl = 0;
	
	printf "L%05d:\t", $brklbl;
	$haslbl = 1;
	
        my ($self, $list) = @_;
        return $list unless ref $list;

	# print "LOOP\n";

        return @$list;
    }

    sub got_if {
	my $filbl = pop @ilabels;
	printf "L%05d:\t", $filbl;
	$haslbl = 1;
	
        my ($self, $list) = @_;
        return $list unless ref $list;

	# print "WHILE\n";

        return @$list;
    }

    sub got_addsub {
        my ($self, $list) = @_;
        return $list unless ref $list;
	#print "COMP: " . join('/', @$list) . "\n";

	while (@$list > 1) {
	    my ($a, $op, $b) = splice(@$list, 0, 3);
	    $a = scope($a, 'persist');
	    $b = scope($b);
	    print "\t" if !$haslbl;
	    print $opcode{$op} . " $a $b $t\n";
	    $haslbl = 0;
	    unshift @$list, "\@$t"; $t++;
	}
        return @$list;
    }

    sub got_expr {
        my ($self, $list) = @_;
        return $list unless ref $list;
	#print "EXPR: " . join('/', @$list) . "\n";
	while (@$list > 1) {
	    my ($s, $v) = splice(@$list, 0, 2);
	    if($s eq '-') {
		if($isdecl) {
		    #my $cv = ((~($v & $maxnum) + 1) & $maxnum);
		    my $cv = -$v & $maxnum;
		    unshift @$list, $cv;
		} else {
		    print "\t" if !$haslbl;
		    ## SCOPE
		    $v = "#$v" if($v =~ /^\d/);
		    print "COM $v $t\n";
		    $haslbl = 0;
		    unshift @$list, "\@$t"; $t++;
		}
	    } else {
		unshift @$list, $v;
	    }
	}

        return @$list;
    }

    sub got_variable {
        my ($self, $list) = @_;
	#print "VAR: " . Dumper($list);
        return $list unless ref $list;

	if(!$isdecl) {
	    #print "VAR: " . join('/', @$list) . "\n";

	    while (@$list > 1) {
		my ($var, $idx) = splice(@$list, 0, 2);
		#print "PreScope: $var $idx\n";
		$var = scope($var, 'array');
		#print "PostScope: $var $idx\n";
		$idx = "#$idx" if($idx =~/^\d+/);
		# use addr not content if not pointer
		$var = "#$var" unless($var =~ /^[\*\@]/);
		print "\t" if !$haslbl;
		print "ADD $var $idx $t\n";
		$haslbl = 0;
		unshift @$list, "*$t"; $t++;
	    }
	}
        return @$list;
    }

    sub got_datastmt {
        my ($self, $list) = @_;
	my $data = shift $list;
	# print "data: " . Dumper($data);
	my $first = 1;
	while(scalar(@$data)) {
	    my $datelem = shift @$data;
	    if(defined $datelem) {
		if($first) {
		    print "DATA=\t";
		    $first = 0;
		} else {
		    print "\t";
		}
		if($datelem < 0) {
		    $datelem &= $maxnum;
		}
		print "MEM $datelem\n" 
	    }
	}
	print "DATPTR=\tMEM DATA\n";
	
        return $list unless ref $list;
	#print "data: " . join('/', @$list) . "\n";

        return @$list;
    }

    sub got_readstmt {
        my ($self, $list) = @_;
	my $read = shift $list;
	#print "read: " . Dumper($read);
	while(scalar(@$read)) {
	    my $rdvar = shift @$read;
	    if(defined $rdvar) {
		print "\t" if !$haslbl;
		$haslbl = 0;
		print "MOV *DATPTR $rdvar\n";
		print "\tADD DATPTR #1 DATPTR\n";
	    }
	}

        return $list unless ref $list;
	#print "data: " . join('/', @$list) . "\n";

        return @$list;
    }

    sub got_datareset {
        my ($self, $list) = @_;
	print "\t" if !$haslbl;
	$haslbl = 0;
	print "MOV #DATA DATPTR\n";

        return $list unless ref $list;
	#print "rule: " . join('/', @$list) . "\n";

        return @$list;
    }

    sub got_pragma {
        my ($self, $list) = @_;
        return $list unless ref $list;
	my ($name, $body) = splice(@$list, 0, 2);
	print "#PRAGMA\t$name $body\n";

        return @$list;
    }
    
    sub gotrule {
        my ($self, $list) = @_;
        return $list unless ref $list;
	#print "rule: " . join('/', @$list) . "\n";

        return @$list;
    }

    sub final {
	print "\t" if !$haslbl;
	$haslbl = 0;
	print "HLT\n";
	print "HEAP:\tMEM 0\n";
        my ($self, $list) = @_;
        return $list unless ref $list;

        return @$list;
    }	
}

sub preprocess {
}

# cmdline options
my ($srcfile, $outfile, $helpme);
our $bits = 10;

GetOptions(
    "help|?" => \$helpme,
    "output=s" => \$outfile,
    "bits=i" => \$bits,
    ) or die("FATAL: Cannot understand options.\n");

my ($srcfile, $endguard) = @ARGV;
die "Usage: shlc [ -o <outfile> ] srcfile\n" 
    if(!defined $srcfile || defined $endguard || defined $helpme);

my $out = *STDOUT;
if(defined $outfile) {
    open($out, '>', $outfile) or die("FATAL: Cannot open $outfile for writing.\n");
}

my $src = read_file($srcfile, chomp => 1);
pegex($grammar, 'Shla')->parse($src);

1; # EOF
